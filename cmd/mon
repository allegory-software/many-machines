#!/bin/bash
# MONITOR ; [start|stop|restart|status [-q]|reset] ; contiunous monitoring service
. mmlib

checkvars MACHINE

mon_pid() { pgrep -f 'bin/bash cmd/mon daemon'; }

if [[ $1 == start ]]; then
	pid=`mon_pid` && die "Already running. PID: $pid"
	nohup "$0" daemon >/dev/null 2> mon.log &
	exit
elif [[ $1 == stop ]]; then
	pid=`mon_pid` || die "Not running."
	kill $pid
	while kill -0 $pid 2>/dev/null; do sleep 0.1; done
	exit
elif [[ $1 == restart ]]; then
	"$0" stop
	"$0" start
	exit
elif [[ $1 == status ]]; then
	pid=`mon_pid`; x=$?
	[[ $2 == -q ]] || { [[ $x == 0 ]] && say "Running. PID: $pid" || say "Not running."; }
	exit $x
elif [[ $1 == reset ]]; then
	REL_PATH_OK=1 empty_dir mon/alerts
	REL_PATH_OK=1 rm_file mon/notified
	exit
elif [[ $1 == pause ]]; then
	touch mon/paused
	exit
elif [[ $1 == resume || $1 == unpause ]]; then
	REL_PATH_OK=1 rm_file mon/paused
	exit
fi

# config ---------------------------------------------------------------------

# thresholds
MIN_RAM_MB=50
MIN_HDD_MB=2000

# intervals
PROBE_TICK=3
NOTIFY_TICK=3600

# ----------------------------------------------------------------------------

RAM_KB=`get_RAM_KB`
HDD_KB=`get_HDD_KB`

MIN_RAM_KB=$((MIN_RAM_MB * 1024))
MIN_HDD_KB=$((MIN_HDD_MB * 1024))

# change the log file when today becomes tomorrow.
set_file() {
	T0=`date -d '00:00' +%s`
	T1=`date -d 'tomorrow 00:00' +%s`
	FILE=`date +%F`
}
set_file

# count consecutive times when value was out of range.
# we only report values that were out of range more than MAXC times.
declare -A COUNTS # k->n

log() { # K= V= MIN= MAX= [MAXC=] N= P= T= T0= DIR= FILE=

	# log the value in samples file to show in a graph
	[[ -d $DIR/$K ]] || {
		must mkdir -p $DIR/$K
		printf "%d\n" $MIN > $DIR/$K/min
		printf "%d\n" $MAX > $DIR/$K/max
	}
	printf "%05d %s\n" $((T - T0)) $V >> $DIR/$K/$FILE.sam

	# check alert thresholds
	local ALERT
	if ((V < MIN || V > MAX)); then
		((COUNTS[$K]++))
		local C=${COUNTS[$K]}
		local MAXC=${MAXC:-0}
		if ((C > MAXC)); then
			ALERT=!
		fi
	else
		COUNTS[$K]=0
	fi

	# show the value when running mon in foreground.
	printf "%15s %1s %s\n" $K "$ALERT" $V

	# record alert
	[[ $ALERT != "" ]] && {
		local file=mon/alerts/$K
		must mkdir -p mon/alerts
		printf "%s\n" $V > $file
	}
}

notify() {
	[[ -f mon/notified && $(find mon/notified -mmin -1440) ]] && return # notify once a day
	touch mon/notified
	must mkdir -p mon/alerts
	must pushd mon/alerts
	local f s=
	set +f # enable globbing
	for f in *; do
		s="$s$f: $(cat "$f")"$'\n'
	done
	set -f # disable globbing
	must popd
	[[ $s ]] || return
	mm ntfy -H "Tags: warning" -H "Title: MM @ $MACHINE ALERT" -d "$s"
}

# stop the loop on Ctrl+C
stop=
trap 'stop=1' SIGTERM SIGINT

N=0
on_tick() { ((N % $1 == 0)); }
next_tick() {
	N=$((N+1))
	printf .
	sleep 1
}
while [[ ! $stop ]]; do

	[[ -f mon/paused ]] && {
		next_tick
		continue
	}

	on_tick $PROBE_TICK && {

		echo
		echo

		T=`date +%s`
		((T1 > T)) || set_file

		printf "%15s %s\n" @ "$(date '+%F %T')"

		DIR=mon/samples

		# proble RAM and HDD free space

		K=RAM V=`get_FREE_RAM_KB` MAX=$RAM_KB MIN=$MIN_RAM_KB log
		K=HDD V=`get_FREE_HDD_KB` MAX=$HDD_KB MIN=$MIN_HDD_KB log

		# probe CPU load

		stats2=()
		while IFS= read -r line; do
			[[ $line == cpu[0-9]* ]] && stats2+=("$line")
		done < /proc/stat

		if declare -p stats1 &>/dev/null; then # we have at least 2 samples
			for i in "${!stats1[@]}"; do # go through all cpu cores
				read -a f1 <<<"${stats1[i]}"
				read -a f2 <<<"${stats2[i]}"

				idle1=${f1[4]}
				idle2=${f2[4]}

				total1=0 total2=0
				for n in "${f1[@]:1}"; do ((total1+=n)); done
				for n in "${f2[@]:1}"; do ((total2+=n)); done

				total=$((total2 - total1))
				idle=$((idle2 - idle1))
				usage=$((100 * (total - idle) / total))
				K=CPU V=$usage MAX=10 MIN=0 log
			done
		fi
		stats1=("${stats2[@]}")

		# probe deploy service status

		active_deploys; DEPLOYS=$R1
		for DEPLOY in $DEPLOYS; do
			machine_of_deploy $DEPLOY; [[ $R1 != $MACHINE ]] && continue
			md_var DEPLOY_SERVICES; DEPLOY_SERVICES=$R1
			md_var APP; APP=$R1
			for SERVICE in $DEPLOY_SERVICES; do
				md_is_running $SERVICE && V=1 || V=0
				K=d-${DEPLOY}-${SERVICE} MAX=1 MIN=1 log
			done
		done
		DEPLOY=

		# probe machine service status

		md_var SERVICES; SERVICES=$R1
		for SERVICE in $SERVICES; do
			md_is_running $SERVICE && V=1 || V=0
			K=s-$SERVICE MAX=1 MIN=1 log
		done

		echo

	}

	on_tick $NOTIFY_TICK && notify

	next_tick
done
say "Stopped."
