#!/bin/bash
# MONITOR ; [start|stop|restart|status [-q]|reset|pause|resume|unpause|clear-samples] ; continuous monitoring service
. mmlib

# make mon start without mm (systemd service runs it directly).
[[ $THIS_MACHINE ]] || THIS_MACHINE=`basename "$(readlink machine)"`
checkvars THIS_MACHINE
MACHINE=$THIS_MACHINE

# config ---------------------------------------------------------------------

# probing intervals
PROBE_TICK=${PROBE_TICK:-60}

# parse cmdline & damonize ---------------------------------------------------

must mkdir -p mon/alerts
must mkdir -p mon/notified
must mkdir -p mon/samples

mon_pid() { pgrep -f 'bin/bash cmd/mon daemon'; }

RUN=
if [[ $1 == start ]]; then
	pid=`mon_pid` && die "Already running. PID: $pid"
	nohup "$0" daemon >/dev/null 2> mon.log &
elif [[ $1 == stop ]]; then
	pid=`mon_pid` || die "Not running."
	kill $pid
	while kill -0 $pid 2>/dev/null; do sleep 0.1; done
elif [[ $1 == restart ]]; then
	"$0" stop
	"$0" start
elif [[ $1 == status ]]; then
	pid=`mon_pid`; x=$?
	[[ $2 == -q ]] || { [[ $x == 0 ]] && say "Running. PID: $pid" || say "Not running."; }
	exit $x
elif [[ $1 == reset ]]; then
	REL_PATH_OK=1 empty_dir mon/alerts
	REL_PATH_OK=1 empty_dir mon/notified
elif [[ $1 == pause ]]; then
	touch mon/paused
elif [[ $1 == resume || $1 == unpause ]]; then
	REL_PATH_OK=1 rm_file mon/paused
elif [[ $1 == clear-samples ]]; then
	[[ $2 == please ]] || die "Say please."
	REL_PATH_OF=1 rm_dir mon/samples
elif [[ $1 == daemon || $1 == systemd ]]; then
	RUN=1
	DAEMON=1
elif [[ $1 ]]; then
	die "Invalid arg: $1"
else
	RUN=1
fi
[[ $RUN ]] || exit 0

# sample logging & alerts ----------------------------------------------------

# change the log file when today becomes tomorrow.
set_file() {
	T0=`date -d '00:00' +%s`
	T1=`date -d 'tomorrow 00:00' +%s`
	FILE=`date +%F`
}
set_file

# count consecutive times when value was out of range.
# we only report values that were out of range more than MAXT times.
declare -A COUNTS # k->n

log() { # K= V= MIN= MAX= [MAXT=] T= T0= DIR= FILE=

	# log the value in samples file to show in a graph
	[[ $DAEMON ]] && {
		[[ -d mon/samples/$K ]] || {
			must mkdir -p mon/samples/$K
			printf "%d\n" $MIN > mon/samples/$K/min
			printf "%d\n" $MAX > mon/samples/$K/max
		}
		printf "%05d %s\n" $((T - T0)) $V >> mon/samples/$K/$FILE.sam
	}

	# check alert thresholds
	local ALERT
	if ((V < MIN || V > MAX)); then
		((COUNTS[$K]++))
		local C=${COUNTS[$K]}
		local MAXT=${MAXT:-1}
		if ((C >= MAXT)); then
			ALERT=!
		fi
	else
		COUNTS[$K]=0
	fi

	# show the value when running mon in foreground.
	printf "%25s %1s %s\n" $K "$ALERT" $V

	# record alert
	[[ $DAEMON && $ALERT ]] && {
		local file=mon/alerts/$K
		printf "%s\n" $V > $file
	}
}

notify() {
	[[ $DAEMON ]] || return
	must pushd mon/alerts
	local f s
	# list alerts of < 24h ago and notify at most once every 24h for each.
	for f in `find -maxdepth 1 -type f -mmin -1440 -printf '%f\n'`; do
		[[ -f ../notified/$f && $(find ../notified/$f -mmin -1440) ]] && continue
		touch ../notified/$f
		local t=`stat -c %Y $f` # mtime in seconds
		timeago $t; t=$R1
		catfile $f; local v=$R1
		s="$s$f: $v ($t)"$'\n'
	done
	must popd
	[[ $s ]] || return
	dry mm ntfy -H "Tags: warning" -H "Title: MM @ $MACHINE ALERT" -d "$s"
}

# probing modules ------------------------------------------------------------

md_var MIN_FREE_RAM_MB 50; MIN_FREE_RAM_MB=$R1
md_var MAXT_FREE_RAM 1; MAXT_FREE_RAM=$R1
RAM_MB=`cat /proc/meminfo | awk '/MemTotal/ {print int($2/1024)}'`
probe_ram() {
	local FREE_RAM_MB=`cat /proc/meminfo | awk '/MemAvailable/ {print int($2/1024)}'`
	K=RAM V=$FREE_RAM_MB MAX=$RAM_MB MIN=$MIN_FREE_RAM_MB MAXT=$MAXT_FREE_RAM log
}

probe_disks() {
	local name fstype mount label size avail
	while read name fstype mount label; do
		[[ $mount ]] || continue
		[[ $mount == /boot/efi ]] && continue
		[[ $fstype == ext4 ]] || continue
		[[ $mount == / ]] && label=root
		[[ $label ]] || label=`basename $mount`
		read size avail < <(df -m --output=size,avail $mount | tail -n1)
		md_var MIN_FREE_${LABEL}_MB 2048; local MIN=$R1
		K=FREE-$label V=$avail MAX=$size log
	done < <(lsblk -ln -o NAME,FSTYPE,MOUNTPOINT,LABEL)
}

md_var MAX_CPU 90; MAX_CPU=$R1
md_var MAXT_CPU 1; MAXT_CPU=$R1
unset CPU_STATS1
unset CPU_STATS2
probe_cpu() {
	CPU_STATS2=()
	local line
	while IFS= read -r line; do
		[[ $line == cpu[0-9]* ]] && CPU_STATS2+=("$line")
	done < /proc/stat

	if declare -p CPU_STATS1 &>/dev/null; then # we have at least 2 samples
		local i
		for i in "${!CPU_STATS1[@]}"; do # go through all cpu cores
			local -a f1; read -a f1 <<<"${CPU_STATS1[i]}"
			local -a f2; read -a f2 <<<"${CPU_STATS2[i]}"

			local idle1=${f1[4]}
			local idle2=${f2[4]}

			local total1=0 total2=0
			local n; for n in "${f1[@]:1}"; do ((total1+=n)); done
			local n; for n in "${f2[@]:1}"; do ((total2+=n)); done

			local total=$((total2 - total1))
			local idle=$((idle2 - idle1))
			local usage=$((100 * (total - idle) / total))
			K=CPU$i V=$usage MAX=$MAX_CPU MIN=0 MAXT=$MAXT_CPU log
		done
	fi
	CPU_STATS1=("${CPU_STATS2[@]}")
}

probe_deploy_services() {
	machine_deploys
	local DEPLOY
	for DEPLOY in $R1; do
		md_var DEPLOY_SERVICES; local DEPLOY_SERVICES=$R1
		md_var APP; local APP=$R1
		for SERVICE in $DEPLOY_SERVICES; do
			local V; md_is_running $SERVICE && V=1 || V=0
			K=service-${SERVICE}-${DEPLOY} MAX=1 MIN=1 log
		done
	done
}

probe_services() {
	md_var SERVICES; local SERVICES=$R1
	for SERVICE in $SERVICES; do
		[[ $SERVICE == mon ]] && continue
		local V; md_is_running $SERVICE && V=1 || V=0
		K=service-$SERVICE MAX=1 MIN=1 log
	done
}

probe_ups() {
	md_modules; echo "$R1" | grep -qw ups || return
	local CHARGE=`upsc ups@localhost battery.charge 2>/dev/null`
	K=BATTERY-CHARGE V=CHARGE MAX=100 MIN=50 log

	# poweroff this machine and others tied to the same ups if battery charge < 20%.
	[[ $DAEMON && $CHARGE ]] && (( CHARGE <= 20 )) && {
		md_var UPS_MACHINES; local UPS_MACHINES=$R1
		local s
		local M; for M in $UPS_MACHINES; do
			[[ $M == $MACHINE ]] && continue
			dry mm $M - poweroff
			s="${s}Powered off: $M"$'\n'
		done
		s="${s}Powering off: $MACHINE"$'\n'
		dry mm ntfy -H "Tags: sob" -H "Title: MM @ $MACHINE POWERING OFF" -d "$s"
		dry poweroff
	}
}

probe_temps() {
	# get CPU temp
	catfile /sys/class/thermal/thermal_zone1/temp
	K=TEMP_CPU V=$(($R1 / 1000)) MAX=70 MIN=20 log
	# get temp of hottest NVME
	K=TEMP_NVME V=`sensors -j 2>/dev/null | jq '[. as $root | keys[] | select(test("nvme")) | $root[.].Composite.temp1_input?] | max | round'` MAX=70 MIN=20 log
}

probe_nvmes() {
	local NVME; for NVME in `ls /sys/class/nvme`; do
		local warn spare used errs
		read -r warn spare used errs < <(
			# querying nvme is slow so we get all vars with one query.
			nvme smart-log /dev/$NVME -o json | \
				jq -r '[.critical_warning, .avail_spare, .percent_used, .media_errors] | @tsv'
		)
		K=${NVME}-warn   V=$warn  MAX=0   MIN=0  log # bitmask of serious health issues
		K=${NVME}-spare  V=$spare MAX=100 MIN=10 log # drive is near EOL if < 10
		K=${NVME}-wear   V=$used  MAX=80  MIN=0  log # lifespan indicator
		K=${NVME}-errors V=$errs  MAX=0   MIN=0  log # data loss events
	done
}

# main loop ------------------------------------------------------------------

# trap Ctrl+C to stop the loop cleanly.
STOP=
trap 'STOP=1' SIGTERM SIGINT

next_tick() {
	sleep $PROBE_TICK  # returns immediately on Ctrl+C
}
while [[ ! $STOP ]]; do

	[[ -f mon/paused ]] && {
		next_tick
		continue
	}

	echo

	T=`date +%s`
	((T1 > T)) || set_file

	printf "%15s %1s %s\n" @ "" "$(date '+%F %T')"

	P probe_disks
	P probe_cpu
	P probe_ram
	P probe_deploy_services
	P probe_services
	P probe_ups
	P probe_temps
	P probe_nvmes

	echo

	P notify

	next_tick
done
say "Stopped."
