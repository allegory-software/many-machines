#!/bin/bash
# MONITOR ; [start|stop|restart|status [-q]] ; contiunous monitoring service
. mmlib

checkvars MACHINE

mon_pid() { pgrep -f 'bin/bash cmd/mon daemon'; }

if [[ $1 == start ]]; then
	pid=`mon_pid` && die "Already running. PID: $pid"
	nohup "$0" daemon >/dev/null 2> mon.log &
	exit
elif [[ $1 == stop ]]; then
	pid=`mon_pid` || die "Not running."
	kill $pid
	exit
elif [[ $1 == restart ]]; then
	"$@" stop
	"$@" start
	exit
elif [[ $1 == status ]]; then
	pid=`mon_pid`; x=$?
	[[ $2 == -q ]] || { [[ $x == 0 ]] && say "Running. PID: $pid" || say "Not running."; }
	exit $x
fi

# config ---------------------------------------------------------------------

MIN_RAM_MB=50
MIN_HDD_MB=2000

TICK=60 # probing interval
NOTIFY_TICK=3600

# ----------------------------------------------------------------------------

RAM_KB=`get_RAM_KB`
HDD_KB=`get_HDD_KB`

MIN_RAM_KB=$((MIN_RAM_MB * 1024))
MIN_HDD_KB=$((MIN_HDD_MB * 1024))

# change log file when today becomes tomorrow.
set_file() {
	T0=`date -d '00:00' +%s`
	T1=`date -d 'tomorrow 00:00' +%s`
	FILE=`date +%F`
}
set_file

log() { # K= V= MIN= MAX= N= P= T= T0= DIR= FILE=
	[[ -d $DIR/$K ]] || {
		must mkdir -p $DIR/$K
		printf "%d\n" $MIN > $DIR/$K/min
		printf "%d\n" $MAX > $DIR/$K/max
	}
	printf "%05d %s\n" $((T - T0)) $V >> $DIR/$K/$FILE.sam
	local ALERT; ((V < MIN || V > MAX)) && ALERT=!
	printf "%15s %1s %s\n" $K "$ALERT" $V
	[[ $ALERT != "" ]] && {
		local file=mon/alerts/$K
		must mkdir -p mon/alerts
		printf "%s\n" $V > $file
	}
}

notify() {
	[[ -f mon/notified && $(find mon/notified -mmin -1440) ]] && return # once a day
	touch mon/notified
	must pushd mon/alerts
	set +f # enable globbing
	local f s=
	for f in *; do
		s="$s$f: $(cat "$f")"$'\n'
	done
	must popd
	mm ntfy -H "Tags: warning" -H "Title: MM @ $MACHINE ALERT" -d "$s"
}

stop=
trap 'stop=1' SIGTERM SIGINT

N=0
while [[ ! $stop ]]; do

	((N % $TICK == 0)) && {
		echo

		T=`date +%s`
		((T1 > T)) || set_file

		printf "%15s %s\n" @ "$(date '+%F %T')"

		DIR=mon/samples

		K=RAM V=`get_FREE_RAM_KB` MAX=$RAM_KB MIN=$MIN_RAM_KB log
		K=HDD V=`get_FREE_HDD_KB` MAX=$HDD_KB MIN=$MIN_HDD_KB log

		active_deploys; DEPLOYS=$R1
		for DEPLOY in $DEPLOYS; do
			machine_of_deploy $DEPLOY; [[ $R1 != $MACHINE ]] && continue
			md_var DEPLOY_SERVICES; DEPLOY_SERVICES=$R1
			md_var APP; APP=$R1
			for SERVICE in $DEPLOY_SERVICES; do
				md_is_running $SERVICE && V=1 || V=0
				K=d-${DEPLOY}-${SERVICE} MAX=1 MIN=1 log
			done
		done
		DEPLOY=

		md_var SERVICES; SERVICES=$R1
		for SERVICE in $SERVICES; do
			md_is_running $SERVICE && V=1 || V=0
			K=s-$SERVICE MAX=1 MIN=1 log
		done

		echo
	}

	((N % $NOTIFY_TICK == 0)) && {
		notify
	}

	N=$((N+1))
	printf .
	sleep 1
done
say "Stopped."
